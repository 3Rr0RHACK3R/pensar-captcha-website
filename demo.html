<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pensar Captcha - Live Demo: Test Your Humanity!</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #f3f4f6;
            padding: 1rem;
        }
        .container {
            background-color: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            border-radius: 20px;
        }
        .nav-link {
            padding: 0.75rem 1.5rem;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            transition: background-color 0.3s ease-in-out, transform 0.2s ease-in-out;
            white-space: nowrap;
        }
        .nav-link:hover {
            background-color: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
        }
        .nav-link.active {
            background-color: #4f46e5;
            font-weight: 700;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        .action-button {
            background: linear-gradient(90deg, #48bb78 0%, #38a169 100%); /* Green gradient */
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease-in-out;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        .action-button:hover {
            background: linear-gradient(90deg, #38a169 0%, #48bb78 100%); /* Reverse gradient on hover */
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.3);
        }
        .action-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            align-items: center;
        }
        .input-group input[type="url"] {
            width: 100%;
            max-width: 400px;
            padding: 0.75rem 1rem;
            border: 1px solid #4a5568;
            border-radius: 0.5rem;
            background-color: #2d3748;
            color: #e2e8f0;
            font-size: 1rem;
            box-sizing: border-box;
        }
        .input-group label {
            font-size: 1rem;
            font-weight: 600;
            color: #cbd5e1;
            margin-bottom: 0.5rem;
        }

        /* --- Pensar Captcha Client-Side Snippet Styles (copied from client_integration_snippet.html) --- */
        #pensar-captcha-container {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            border-radius: 1rem; /* Rounded corners */
            padding: 2rem;
            max-width: 400px;
            margin: 2rem auto; /* Center it */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
            color: #e2e8f0; /* Light text */
            text-align: center;
            position: relative; /* For absolute positioning of logo */
            overflow: hidden; /* Ensure nothing overflows */
            padding-bottom: 3.5rem; /* Make space for the branding at the bottom */
        }

        #pensar-captcha-container h3 {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            color: #63b3ed; /* Blue heading */
        }

        #pensar-captcha-container input[type="text"] {
            width: calc(100% - 2rem); /* Full width minus padding */
            padding: 0.75rem 1rem;
            margin-bottom: 1rem;
            border: 1px solid #4a5568; /* Darker border */
            border-radius: 0.5rem;
            background-color: #2d3748; /* Even darker input background */
            color: #e2e8f0;
            font-size: 1rem;
            box-sizing: border-box; /* Include padding in width */
        }

        #pensar-captcha-container button {
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); /* Purple gradient button */
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            width: 100%;
        }

        #pensar-captcha-container button:hover {
            background: linear-gradient(90deg, #764ba2 0%, #667eea 100%); /* Reverse gradient on hover */
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        #pensar-captcha-container .message {
            margin-top: 1rem;
            font-size: 0.9rem;
            color: #a0aec0; /* Gray message */
        }

        #pensar-captcha-container .success {
            color: #48bb78; /* Green for success */
            font-weight: 600;
        }

        #pensar-captcha-container .error {
            color: #f56565; /* Red for error */
            font-weight: 600;
        }

        /* Interactive Captcha Specific Styles */
        #pensar-captcha-container canvas {
            border: 1px solid #4a5568;
            background-color: #2d3748;
            border-radius: 0.5rem;
            margin-top: 1rem;
            touch-action: none; /* Prevent default touch actions like scrolling/zooming */
            display: block; /* Ensure it takes full width */
            width: 100%; /* Make canvas responsive */
            height: 200px; /* Fixed height, or make it responsive with JS */
        }

        /* Logical Ordering Captcha Styles */
        .logical-ordering-items {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        .logical-ordering-item {
            background-color: #4a5568;
            padding: 0.75rem;
            border-radius: 0.5rem;
            cursor: grab;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            color: #e2e8f0;
            font-size: 0.9rem;
            text-align: left;
        }
        .logical-ordering-item:hover {
            background-color: #636b7b;
        }
        .logical-ordering-item.dragging {
            background-color: #5a67d8;
            transform: scale(1.02);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        /* Pattern Recognition Grid Styles */
        .pattern-grid-container {
            display: grid;
            gap: 0.5rem; /* Space between grid items */
            margin-top: 1rem;
            width: fit-content; /* Adjust width to content */
            margin-left: auto;
            margin-right: auto;
            border: 1px solid #4a5568;
            border-radius: 0.5rem;
            padding: 0.5rem;
            background-color: #2d3748;
        }
        .pattern-grid-item {
            width: 45px; /* Fixed size for grid items */
            height: 45px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #4a5568;
            border-radius: 0.3rem;
            font-size: 1.2rem; /* Larger font for visibility */
            font-weight: bold;
            color: #e2e8f0;
        }

        /* Pensar Captcha Branding */
        .pensar-branding {
            position: absolute; /* Position relative to parent container */
            bottom: 0.75rem; /* 12px from the bottom */
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 0.4rem; /* Space between logo and text */
            font-size: 0.75rem; /* text-xs */
            color: #a0aec0; /* Light gray text */
            white-space: nowrap; /* Keep text on one line */
        }

        .pensar-branding a {
            color: #a0aec0; /* Link color same as text */
            text-decoration: none; /* No underline by default */
            transition: color 0.2s ease-in-out;
        }

        .pensar-branding a:hover {
            color: #cbd5e1; /* Slightly lighter on hover */
            text-decoration: underline; /* Underline on hover */
        }

        .pensar-logo-svg {
            width: 1.2rem; /* Slightly larger for impact */
            height: 1.2rem;
            flex-shrink: 0; /* Prevent shrinking */
        }
        .pensar-logo-svg .shield-base {
            fill: #63b3ed; /* Blue for the shield */
        }
        .pensar-logo-svg .shield-letter {
            fill: #1a202c; /* Dark color for the 'P' inside the shield */
            font-family: 'Inter', sans-serif; /* Use Inter for the letter */
            font-weight: bold;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 600px) {
            #pensar-captcha-container {
                padding: 1.5rem;
                margin: 1rem auto;
            }
            #pensar-captcha-container h3 {
                font-size: 1.25rem;
            }
            #pensar-captcha-container input[type="text"],
            #pensar-captcha-container button {
                font-size: 0.9rem;
                padding: 0.6rem 1.2rem;
            }
            .pensar-branding {
                font-size: 0.65rem;
                bottom: 0.5rem;
            }
            .pensar-logo-svg {
                width: 1rem;
                height: 1rem;
            }
            .pattern-grid-item {
                width: 35px;
                height: 35px;
                font-size: 1rem;
            }
        }
    </style>
</head>
<body class="p-4 sm:p-6 md:p-8">
    <div class="container max-w-4xl w-full p-6 sm:p-8 md:p-10 lg:p-12 text-center flex flex-col items-center space-y-8 rounded-xl">
        <!-- Navigation Bar -->
        <nav class="w-full mb-8">
            <ul class="flex flex-wrap justify-center gap-4 text-lg font-semibold text-white">
                <li><a href="index.html" class="nav-link">Home</a></li>
                <li><a href="update-log.html" class="nav-link">Update Log</a></li>
                <li><a href="software-download.html" class="nav-link">Download</a></li>
                <li><a href="demo.html" class="nav-link active">Live Demo</a></li> <!-- New Nav Link -->
                <li><a href="license.html" class="nav-link">License</a></li>
                <li><a href="donate.html" class="nav-link">💖 Donate</a></li>
            </ul>
        </nav>

        <header class="mb-8">
            <h1 class="text-4xl sm:text-5xl lg:text-6xl font-extrabold mb-4 leading-tight text-white drop-shadow-lg">
                <span class="block">Pensar Captcha:</span> <span class="block mt-2">Live Demo - Test Your Humanity!</span>
            </h1>
            <p class="text-lg sm:text-xl lg:text-2xl text-indigo-100 italic">
                Ready to prove you're not a bot? Connect your own backend and experience Pensar Captcha's power!
            </p>
        </header>

        <main class="w-full text-left">
            <section class="mb-8 p-6 bg-white bg-opacity-10 rounded-xl shadow-lg">
                <h2 class="text-2xl sm:text-3xl font-bold mb-4 text-white text-center">
                    Connect Your Own Bot-Buster Backend!
                </h2>
                <p class="text-lg text-indigo-100 mb-6 text-center">
                    This is where the magic happens! To test Pensar Captcha with *your* very own backend (running on your local machine and exposed via ngrok, LocalXpose, or localtunnel), simply paste your public API URL below. Make sure your `BotBuster.exe` and `Algorithms.exe` are running locally and your tunnel is active!
                </p>
                <div class="input-group">
                    <label for="apiURLInput">Your Pensar Captcha API URL (e.g., `https://your-tunnel.ngrok-free.app`):</label>
                    <input type="url" id="apiURLInput" placeholder="https://your-epic-tunnel.example.com" value="https://127.0.0.1:5000"> <!-- Changed default value to include https:// -->
                    <button id="connectApiBtn" class="action-button w-full sm:w-auto">Connect & Load Captcha!</button>
                </div>
                <p id="connectionStatus" class="message text-center"></p>
            </section>

            <!-- The Pensar Captcha client-side snippet will be injected here -->
            <div id="pensar-captcha-container" style="display: none;">
                <!-- Captcha content will be dynamically loaded here by JavaScript -->
                <h3 id="captchaTitle">Verifying Humanity...</h3>
                <div id="captchaChallengeArea">
                    <p class="message">Please wait while we load your challenge...</p>
                </div>
                <input type="text" id="captchaInput" placeholder="Enter your answer here" style="display: none;">
                <button id="captchaSubmitBtn" style="display: none;">Submit</button>
                <p class="message" id="captchaMessage"></p>

                <!-- Pensar Captcha Branding -->
                <div class="pensar-branding">
                    <svg class="pensar-logo-svg" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path class="shield-base" d="M12 2L3 6V17C3 20.866 6.13401 24 10 24C10.6476 24 11.2782 23.9016 11.8845 23.7145L12 23.6667L12.1155 23.7145C12.7218 23.9016 13.3524 24 14 24C17.866 24 21 20.866 21 17V6L12 2Z" fill="currentColor"/>
                        <text class="shield-letter" x="12" y="15" text-anchor="middle" font-size="12" font-weight="bold">P</text>
                    </svg>
                    <a href="https://pensarcaptcha.netlify.app" target="_blank" rel="noopener noreferrer">
                        Powered by Pensar Captcha
                    </a>
                </div>
            </div>
            <p class="text-center text-sm text-indigo-200 mt-4">
                (If you're testing locally, `http://127.0.0.1:5000` is your default API URL!)
            </p>
        </main>

        <footer class="mt-8 text-center text-sm text-indigo-200">
            <p>&copy; 2025 Pensar Captcha. All rights reserved. Our demos are forged in the fires of bot frustration!</p>
            <p class="mt-2">
                Made with passion and a healthy dose of anti-bot sentiment.
                <span class="block mt-1">Disclaimer: May cause extreme digital meltdowns in unprepared AI. You've been warned!</span>
            </p>
        </footer>
    </div>

    <script>
        // --- Pensar Captcha Client-Side Logic (Adapted for Demo Page) ---
        // This script handles the display, interaction, and verification of the captcha.
        // It communicates with the Pensar Captcha Backend API.

        const PENSAR_CAPTCHA_WEBSITE_URL = "https://pensarcaptcha.netlify.app"; // Your marketing website URL

        const captchaContainer = document.getElementById('pensar-captcha-container');
        const captchaTitle = document.getElementById('captchaTitle');
        const captchaChallengeArea = document.getElementById('captchaChallengeArea');
        const captchaInput = document.getElementById('captchaInput');
        const captchaSubmitBtn = document.getElementById('captchaSubmitBtn');
        const captchaMessage = document.getElementById('captchaMessage');

        const apiURLInput = document.getElementById('apiURLInput');
        const connectApiBtn = document.getElementById('connectApiBtn');
        const connectionStatus = document.getElementById('connectionStatus');

        let CAPTCHA_API_BASE_URL = apiURLInput.value; // Initialize with default or user's last input

        let currentCaptchaId = null;
        let currentChallengeType = null;
        let mousePath = [];
        let keypressData = [];
        let initialLoadTimestamp = null;
        let pasteEventTimestamp = null;
        let backspaceCount = 0;
        let shiftKeyUsed = false;
        let logicalOrderingItems = [];
        let currentLogicalOrder = [];
        let pensarCaptchaIsDrawing = false; // Flag to prevent mouse tracking during drawing

        // --- Behavioral Data Collection Listeners ---
        document.addEventListener('mousemove', (e) => {
            if (currentCaptchaId && !pensarCaptchaIsDrawing) {
                mousePath.push({ x: e.clientX, y: e.clientY, ts: performance.now() });
            }
        });

        document.addEventListener('keydown', (e) => {
            if (currentCaptchaId && captchaInput.style.display === 'block') {
                keypressData.push({ key: e.key, ts: performance.now() });
                if (e.key === 'Backspace') {
                    backspaceCount++;
                }
                if (e.shiftKey) {
                    shiftKeyUsed = true;
                }
            }
        });

        captchaInput.addEventListener('paste', (e) => {
            if (currentCaptchaId) {
                pasteEventTimestamp = performance.now();
            }
        });

        // --- Utility Functions ---

        function showMessage(message, type = 'info') {
            connectionStatus.textContent = ''; // Clear connection status when showing captcha message
            captchaMessage.textContent = message;
            captchaMessage.className = `message ${type}`;
        }

        function showConnectionStatus(message, type = 'info') {
            captchaMessage.textContent = ''; // Clear captcha message when showing connection status
            connectionStatus.textContent = message;
            connectionStatus.className = `message ${type}`;
        }

        function clearCaptchaArea() {
            captchaChallengeArea.innerHTML = '';
            captchaInput.value = '';
            captchaInput.style.display = 'none';
            captchaSubmitBtn.style.display = 'none';
            captchaMessage.textContent = '';
            captchaMessage.className = 'message';
            mousePath = [];
            keypressData = [];
            initialLoadTimestamp = null;
            pasteEventTimestamp = null;
            backspaceCount = 0;
            shiftKeyUsed = false;
            logicalOrderingItems = [];
            currentLogicalOrder = [];
            pensarCaptchaIsDrawing = false; // Reset drawing flag
            captchaContainer.style.display = 'none'; // Hide captcha container until connected
        }

        function getEnvironmentFingerprint() {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            let webglVendor = '';
            let webglRenderer = '';
            let webglEnabled = false;
            if (gl) {
                webglEnabled = true;
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                if (debugInfo) {
                    webglVendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                    webglRenderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                }
            }

            const fonts = [];
            const testFonts = ['Arial', 'Verdana', 'Times New Roman', 'Courier New', 'Georgia', 'Palatino', 'Garamond', 'Comic Sans MS', 'Impact', 'Lucida Sans Unicode', 'Tahoma', 'Trebuchet MS', 'sans-serif', 'serif', 'monospace'];
            const body = document.getElementsByTagName('body')[0];
            const span = document.createElement('span');
            span.style.fontSize = '72px';
            span.innerHTML = 'mmmmmmmmmmlil';
            span.style.position = 'absolute';
            span.style.left = '-9999px';
            span.style.top = '-9999px';

            const defaultWidth = {};
            const defaultHeight = {};

            testFonts.forEach(font => {
                span.style.fontFamily = font;
                body.appendChild(span);
                defaultWidth[font] = span.offsetWidth;
                defaultHeight[font] = span.offsetHeight;
                body.removeChild(span);
            });

            const commonFonts = ['Inter', 'Roboto', 'Open Sans', 'Lato', 'Montserrat', 'Source Sans Pro'];
            commonFonts.forEach(font => {
                span.style.fontFamily = `${font}, sans-serif`;
                body.appendChild(span);
                if (span.offsetWidth !== defaultWidth['sans-serif'] || span.offsetHeight !== defaultHeight['sans-serif']) {
                    fonts.push(font);
                }
                body.removeChild(span);
            });
            
            return {
                userAgent: navigator.userAgent,
                screenWidth: window.screen.width,
                screenHeight: window.screen.height,
                webglEnabled: webglEnabled,
                webglVendor: webglVendor,
                webglRenderer: webglRenderer,
                fonts: fonts,
                plugins: Array.from(navigator.plugins).map(p => p.name),
                language: navigator.language,
                platform: navigator.platform,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
            };
        }

        // --- Captcha Challenge Rendering ---

        function renderTextInputCaptcha(challenge) {
            captchaTitle.textContent = challenge.question;
            captchaChallengeArea.innerHTML = `<p class="message">${challenge.question}</p>`;
            captchaInput.value = '';
            captchaInput.style.display = 'block';
            captchaSubmitBtn.textContent = 'Verify';
            captchaSubmitBtn.style.display = 'block';
            captchaInput.focus();
        }

        function renderDrawingCaptcha(challenge) {
            captchaTitle.textContent = challenge.question;
            captchaChallengeArea.innerHTML = `
                <canvas id="captchaCanvas" width="300" height="200"></canvas>
                <p class="message mt-2">${challenge.instructions}</p>
            `;
            captchaInput.style.display = 'none';
            captchaSubmitBtn.textContent = 'Submit Drawing';
            captchaSubmitBtn.style.display = 'block';

            const canvas = document.getElementById('captchaCanvas');
            const ctx = canvas.getContext('2d');
            let isDrawing = false;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#63b3ed';
            ctx.lineWidth = 2;

            if (challenge.shape === 'circle') {
                ctx.beginPath();
                ctx.arc(canvas.width / 2, canvas.height / 2, 40, 0, Math.PI * 2);
                ctx.stroke();
            } else if (challenge.shape === 'square') {
                ctx.strokeRect(canvas.width / 2 - 40, canvas.height / 2 - 40, 80, 80);
            } else if (challenge.shape === 'triangle') {
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2, canvas.height / 2 - 40);
                ctx.lineTo(canvas.width / 2 + 40, canvas.height / 2 + 40);
                ctx.lineTo(canvas.width / 2 - 40, canvas.height / 2 + 40);
                ctx.closePath();
                ctx.stroke();
            } else if (challenge.shape === 'line') {
                ctx.beginPath();
                ctx.moveTo(50, 75);
                ctx.lineTo(250, 75);
                ctx.stroke();
            }
            
            pensarCaptchaIsDrawing = true; // Set flag to true during drawing
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseleave', stopDrawing);

            canvas.addEventListener('touchstart', startDrawing);
            canvas.addEventListener('touchend', stopDrawing);
            canvas.addEventListener('touchmove', draw);

            function getEventCoords(e) {
                const rect = canvas.getBoundingClientRect();
                if (e.touches) {
                    return {
                        x: e.touches[0].clientX - rect.left,
                        y: e.touches[0].clientY - rect.top
                    };
                }
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }

            function startDrawing(e) {
                e.preventDefault();
                isDrawing = true;
                const { x, y } = getEventCoords(e);
                ctx.beginPath();
                ctx.moveTo(x, y);
                mousePath = [{ x, y, ts: performance.now() }];
                ctx.strokeStyle = '#48bb78';
                ctx.lineWidth = 3;
            }

            function draw(e) {
                if (!isDrawing) return;
                e.preventDefault();
                const { x, y } = getEventCoords(e);
                ctx.lineTo(x, y);
                ctx.stroke();
                mousePath.push({ x, y, ts: performance.now() });
            }

            function stopDrawing() {
                if (!isDrawing) return;
                isDrawing = false;
                ctx.closePath();
                pensarCaptchaIsDrawing = false; // Reset drawing flag after submission
                submitCaptcha(mousePath);
            }
        }

        function renderLogicalOrderingCaptcha(challenge) {
            captchaTitle.textContent = challenge.question;
            const displayHtml = challenge.display_items.map(item => `<div class="logical-ordering-item" draggable="true">${item}</div>`).join('');
            captchaChallengeArea.innerHTML = `<p class="message mb-4">Drag and drop the items into the correct logical order:</p><div id="logicalOrderingItems" class="logical-ordering-items">${displayHtml}</div>`;
            captchaInput.style.display = 'none';
            captchaSubmitBtn.textContent = 'Submit Order';
            captchaSubmitBtn.style.display = 'block';

            const itemsContainer = document.getElementById('logicalOrderingItems');
            logicalOrderingItems = Array.from(itemsContainer.children).map(itemDiv => ({
                text: itemDiv.textContent.trim()
            }));

            let dragSrcEl = null;

            function handleDragStart(e) {
                dragSrcEl = this;
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/html', this.innerHTML);
                this.classList.add('dragging');
                mousePath.push({ x: e.clientX, y: e.clientY, ts: performance.now(), type: 'drag_start' });
            }

            function handleDragOver(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                mousePath.push({ x: e.clientX, y: e.clientY, ts: performance.now(), type: 'drag_over' });
            }

            function handleDragEnter(e) {
                this.classList.add('over');
            }

            function handleDragLeave() {
                this.classList.remove('over');
            }

            function handleDrop(e) {
                e.stopPropagation();
                if (dragSrcEl !== this) {
                    const draggedIndex = Array.from(itemsContainer.children).indexOf(dragSrcEl);
                    const targetIndex = Array.from(itemsContainer.children).indexOf(this);

                    if (draggedIndex < targetIndex) {
                        itemsContainer.insertBefore(dragSrcEl, this.nextSibling);
                    } else {
                        itemsContainer.insertBefore(dragSrcEl, this);
                    }
                }
                mousePath.push({ x: e.clientX, y: e.clientY, ts: performance.now(), type: 'drop' });
                return false;
            }

            function handleDragEnd() {
                this.classList.remove('dragging');
                Array.from(itemsContainer.children).forEach(item => item.classList.remove('over'));
                mousePath.push({ x: event.clientX, y: event.clientY, ts: performance.now(), type: 'drag_end' });
            }

            Array.from(itemsContainer.children).forEach(item => {
                item.addEventListener('dragstart', handleDragStart, false);
                item.addEventListener('dragenter', handleDragEnter, false);
                item.addEventListener('dragover', handleDragOver, false);
                item.addEventListener('dragleave', handleDragLeave, false);
                item.addEventListener('drop', handleDrop, false);
                item.addEventListener('dragend', handleDragEnd, false);
            });

            let currentDragItem = null;

            itemsContainer.addEventListener('touchstart', (e) => {
                const target = e.target;
                if (target.classList.contains('logical-ordering-item')) {
                    e.preventDefault();
                    currentDragItem = target;
                    dragSrcEl = target;
                    currentDragItem.classList.add('dragging');
                    mousePath.push({ x: e.touches[0].clientX, y: e.touches[0].clientY, ts: performance.now(), type: 'touch_drag_start' });

                    const ghost = currentDragItem.cloneNode(true);
                    ghost.style.position = 'absolute';
                    ghost.style.opacity = '0.7';
                    ghost.style.width = currentDragItem.offsetWidth + 'px';
                    ghost.style.pointerEvents = 'none';
                    ghost.style.left = (e.touches[0].clientX - currentDragItem.offsetWidth / 2) + 'px';
                    ghost.style.top = (e.touches[0].clientY - currentDragItem.offsetHeight / 2) + 'px';
                    ghost.id = 'drag-ghost';
                    document.body.appendChild(ghost);
                }
            }, { passive: false });

            itemsContainer.addEventListener('touchmove', (e) => {
                if (currentDragItem) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const ghost = document.getElementById('drag-ghost');
                    if (ghost) {
                        ghost.style.left = (touch.clientX - currentDragItem.offsetWidth / 2) + 'px';
                        ghost.style.top = (touch.clientY - currentDragItem.offsetHeight / 2) + 'px';
                    }

                    const target = getTouchTarget(e);
                    Array.from(itemsContainer.children).forEach(item => item.classList.remove('over'));
                    if (target && target !== currentDragItem && target.classList.contains('logical-ordering-item')) {
                        target.classList.add('over');
                    }
                    mousePath.push({ x: touch.clientX, y: touch.clientY, ts: performance.now(), type: 'touch_drag_move' });
                }
            }, { passive: false });

            itemsContainer.addEventListener('touchend', (e) => {
                if (currentDragItem) {
                    const ghost = document.getElementById('drag-ghost');
                    if (ghost) {
                        ghost.remove();
                    }

                    currentDragItem.classList.remove('dragging');
                    const target = getTouchTarget(e);
                    Array.from(itemsContainer.children).forEach(item => item.classList.remove('over'));

                    if (target && target !== currentDragItem && target.classList.contains('logical-ordering-item')) {
                        const draggedIndex = Array.from(itemsContainer.children).indexOf(currentDragItem);
                        const targetIndex = Array.from(itemsContainer.children).indexOf(target);

                        if (draggedIndex < targetIndex) {
                            itemsContainer.insertBefore(currentDragItem, target.nextSibling);
                        } else {
                            itemsContainer.insertBefore(currentDragItem, target);
                        }
                    }
                    mousePath.push({ x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY, ts: performance.now(), type: 'touch_drag_end' });
                    currentDragItem = null;
                    dragSrcEl = null;
                }
            });
        }

        function renderPatternRecognitionCaptcha(challenge) {
            captchaTitle.textContent = challenge.question;
            const gridSize = challenge.grid_size;
            const gridData = challenge.grid_data;

            let gridHtml = '';
            for (let i = 0; i < gridData.length; i++) {
                gridHtml += `<div class="pattern-grid-item">${gridData[i]}</div>`;
            }

            captchaChallengeArea.innerHTML = `
                <div id="patternGrid" class="pattern-grid-container" style="grid-template-columns: repeat(${gridSize}, 1fr);">
                    ${gridHtml}
                </div>
                <p class="message mt-2">Instructions: ${challenge.instructions}</p>
            `;
            captchaInput.value = '';
            captchaInput.style.display = 'block';
            captchaSubmitBtn.textContent = 'Submit Sequence';
            captchaSubmitBtn.style.display = 'block';
            captchaInput.focus();
        }


        // --- Main Captcha Flow ---

        async function fetchNewCaptcha() {
            if (!CAPTCHA_API_BASE_URL) {
                showConnectionStatus('Please enter your Pensar Captcha API URL above!', 'error');
                return;
            }
            clearCaptchaArea();
            showMessage('Loading a new challenge...', 'info');
            captchaSubmitBtn.disabled = true;
            initialLoadTimestamp = performance.now();

            try {
                const response = await fetch(`${CAPTCHA_API_BASE_URL}/generate_captcha`);
                
                if (!response.ok) {
                    const errorData = await response.json();
                    const errorMessage = errorData.message || `HTTP error! Status: ${response.status}`;
                    if (errorData.bot_detected) {
                        showMessage(errorMessage, 'error');
                        captchaTitle.textContent = 'Bot Detected!';
                        setTimeout(() => {
                            fetchNewCaptcha();
                        }, errorData.retry_after_seconds * 1000 || 5000);
                        return;
                    }
                    throw new Error(errorMessage);
                }

                const data = await response.json();
                
                currentCaptchaId = data.captcha_id;
                currentChallengeType = data.type;

                captchaTitle.textContent = data.question;
                mousePath = [];
                keypressData = [];
                backspaceCount = 0;
                shiftKeyUsed = false;
                pasteEventTimestamp = null;
                clearCaptchaArea(); // Clear previous challenge area fully
                captchaContainer.style.display = 'block'; // Show captcha container

                if (currentChallengeType === 'interactive') {
                    renderDrawingCaptcha(data.challenge_details);
                } else if (currentChallengeType === 'logical_ordering') {
                    renderLogicalOrderingCaptcha(data.challenge_details);
                } else if (currentChallengeType === 'pattern_recognition') {
                    renderPatternRecognitionCaptcha(data.challenge_details);
                } else {
                    renderTextInputCaptcha(data);
                }
                captchaSubmitBtn.disabled = false;

            } catch (error) {
                console.error('Error fetching captcha:', error);
                showMessage('Failed to load captcha. Please ensure your backend is running and reachable at the provided URL.', 'error');
                captchaTitle.textContent = 'Oops! Captcha Error!';
                captchaSubmitBtn.disabled = true;
                captchaContainer.style.display = 'none'; // Hide captcha container on error
            } finally {
                captchaSubmitBtn.disabled = false;
            }
        }

        async function submitCaptcha(answerOverride = null) {
            if (!currentCaptchaId) {
                showMessage('No active captcha to submit.', 'error');
                return;
            }

            let userAnswer = answerOverride;
            
            if (currentChallengeType === 'text_input' || currentChallengeType === 'math_question' || currentChallengeType === 'pattern_recognition') {
                const inputField = document.getElementById('captchaInput');
                userAnswer = inputField ? inputField.value.trim() : '';
            } else if (currentChallengeType === 'logical_ordering') {
                const itemsContainer = document.getElementById('logicalOrderingItems');
                if (itemsContainer) {
                    userAnswer = Array.from(itemsContainer.children).map(itemDiv => itemDiv.textContent.trim());
                }
            }

            const behavioralData = {
                mouse_path: mousePath,
                keypress_data: keypressData,
                environment_fingerprint: getEnvironmentFingerprint(),
                initial_load_timestamp: initialLoadTimestamp,
                paste_event_timestamp: pasteEventTimestamp,
                backspace_count: backspaceCount,
                shift_key_used: shiftKeyUsed,
                final_answer_length: String(userAnswer).length
            };

            showMessage('Verifying your answer...', 'info');
            captchaSubmitBtn.disabled = true;

            try {
                const response = await fetch(`${CAPTCHA_API_BASE_URL}/verify_captcha`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        captcha_id: currentCaptchaId,
                        answer: userAnswer,
                        behavioral_data: behavioralData
                    }),
                });

                const data = await response.json();
                
                if (data.success) {
                    showMessage(data.message || 'Captcha solved! You are human. Welcome!', 'success');
                    setTimeout(() => {
                        clearCaptchaArea();
                        captchaTitle.textContent = 'Human Verified!';
                        showMessage('Thank you for verifying! Feel free to connect again or refresh for a new challenge!', 'success');
                        captchaContainer.style.display = 'none'; // Hide after success
                    }, 2000);

                } else {
                    showMessage(data.message || 'Captcha failed. Please try again.', 'error');
                    if (data.bot_detected) {
                        setTimeout(() => {
                            fetchNewCaptcha();
                        }, data.retry_after_seconds * 1000 || 5000);
                    } else if (data.new_captcha_id) {
                        currentCaptchaId = data.new_captcha_id;
                        currentChallengeType = data.new_captcha_type;
                        captchaTitle.textContent = data.new_captcha_question;
                        mousePath = [];
                        keypressData = [];
                        backspaceCount = 0;
                        shiftKeyUsed = false;
                        pasteEventTimestamp = null;
                        initialLoadTimestamp = performance.now();
                        clearCaptchaArea();
                        captchaContainer.style.display = 'block';

                        if (currentChallengeType === 'interactive') {
                            renderDrawingCaptcha(data.new_challenge_details);
                        } else if (currentChallengeType === 'logical_ordering') {
                            renderLogicalOrderingCaptcha(data.new_challenge_details);
                        } else if (currentChallengeType === 'pattern_recognition') {
                            renderPatternRecognitionCaptcha(data.new_challenge_details);
                        } else {
                            renderTextInputCaptcha({ question: data.new_captcha_question });
                        }
                        captchaSubmitBtn.disabled = false;
                    } else {
                        setTimeout(fetchNewCaptcha, 2500);
                    }
                }

            } catch (error) {
                console.error('Pensar Captcha Verification Error:', error);
                showMessage(`Pensar Captcha Error: ${error.message}. Is your backend running at ${CAPTCHA_API_BASE_URL}?`, 'error');
                setTimeout(fetchNewCaptcha, 2500);
            } finally {
                captchaSubmitBtn.disabled = false;
            }
        }

        // Event listeners
        connectApiBtn.addEventListener('click', () => {
            CAPTCHA_API_BASE_URL = apiURLInput.value.trim();
            if (CAPTCHA_API_BASE_URL) {
                showConnectionStatus('Attempting to connect to your backend...', 'info');
                fetchNewCaptcha();
            } else {
                showConnectionStatus('Please enter a valid API URL!', 'error');
            }
        });

        captchaSubmitBtn.addEventListener('click', () => submitCaptcha());
        captchaInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && captchaInput.style.display !== 'none') {
                submitCaptcha();
            }
        });

        // Initial state: clear captcha area and prompt for URL
        document.addEventListener('DOMContentLoaded', () => {
            clearCaptchaArea();
            showConnectionStatus('Enter your Pensar Captcha API URL and click "Connect" to begin!', 'info');
        });
    </script>
</body>
</html>
